<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>üåç Malawi Groundwater Dashboard</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<!-- Leaflet & Plugins -->
<link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet"/>
<link href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" rel="stylesheet"/>
<link href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" rel="stylesheet"/>
<link href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" rel="stylesheet"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
<script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
    :root {
      --primary: #005aa7;
      --primary-light: #0082c8;
      --secondary: #00a86b;
      --accent: #ff9800;
      --lighter: #e6f2ff;
      --dark: #003366;
      --border: #c0d8f0;
      --danger: #ff4b5c;
    }
    html,body{margin:0;height:100%;font-family:'Segoe UI',sans-serif;background:#f0f7ff;}
    #topbar{position:fixed;top:0;left:0;right:0;height:60px;background:#0A3D62;color:#fff;display:flex;align-items:center;justify-content:space-between;padding:0 20px;z-index:1200;font-weight:600;font-size:20px}
    #container{display:flex;margin-top:60px;height:calc(100vh - 5px);}
    #map{flex:1;height:124%;} /*strech vertically/*/
    #sidebar{width:440px;display:flex;flex-direction:row;background:#fff;border-right:1px solid var(--border);}
    .tabs-container{width:150px;background:var(--lighter);display:flex;flex-direction:column;}
    .tab{padding:15px;text-align:center;margin:4px;cursor:pointer;border-radius:8px;background:#d9e9ff;font-weight:600}
    .tab.active{background:linear-gradient(180deg,var(--primary-light),var(--primary));color:#fff}
    .tab-content-container {
  flex: 1;
  overflow-y: auto;
  padding: 15px;
  height: 124%;       /* stretch vertically */
  box-sizing: border-box;
  background-color: white;
}

    .tabContent{display:none;}
    select,input,button{width:100%;margin:8px 0;padding:8px;border:1px solid var(--border);border-radius:6px}
    button{background:linear-gradient(180deg,var(--primary-light),var(--primary));color:#fff;font-weight:600;cursor:pointer}
    .summary{font-size:12px;color:#555;margin-top:5px;}
    .layerToggle{margin-bottom:10px;}
    .legend{background:white;padding:8px;border-radius:6px;font-size:12px;line-height:18px;box-shadow:0 2px 6px rgba(0,0,0,0.3);}
    .legend div{margin-bottom:4px;}
    .legend span{display:inline-block;width:16px;height:16px;margin-right:6px;vertical-align:middle;}
    /* Raise all Leaflet legends */
.legend {
  margin-bottom: 160px;  /* adjust value to move higher */
}

    .legend i {
  display: inline-block;
  width: 16px;
  height: 16px;
  margin-right: 6px;
  vertical-align: middle;
  border: 1px solid #999; /* optional, to make black visibility: ; */
}

5
    /* Saturday Borehole styles */
    #boreholeSidebar h3 { margin-top:0; }
    .layer-option { margin:6px 0; }
    #countBox { margin-top:10px; font-weight:bold; color:#0077b6; }


    /* ==== Monitoring Styles ==== */
.modal {
  display: none;
  position: fixed;
  z-index: 2000;
  padding-top: 60px;
  left: 0; top: 0;
  width: 100%; height: 100%;
  overflow: auto;
  background: rgba(0,0,0,0.6);
}
.modal-content {
  background: #fff;
  margin: auto;
  padding: 20px;
  border-radius: 12px;
  width: 80%;
  max-width: 900px;
}
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}
.close:hover { color: black; }

/* Search container */
.search-container { position: relative; margin-bottom: 15px;right: 23px }
.search-input { padding-left: 40px; }
.search-icon {
  position: fixed; left: 15px; top: 50%;
  transform: translateY(-50%); color: var(--primary-light);
  pointer-events: none;
}

/* Station info */
.station-info {
  background: #f0f8ff;
  padding: 15px; border-radius: 8px;
  border: 1px solid var(--border);
  margin: 15px 0;
  display: grid; grid-template-columns: 1fr 1fr;
  gap: 10px;
}
.info-item { display: flex; flex-direction: column; }
.info-label { font-weight: 600; color: var(--primary); font-size: 12px; margin-bottom: 4px; }
.info-value { color: var(--dark); font-size: 14px; }

/* Radio buttons */
.radio-group { display: flex; gap: 15px; margin: 10px 0; }
.radio-option { display: flex; align-items: center; gap: 5px; }

/* View buttons */
#visualization-controls { margin: 10px 0; display: flex; gap: 10px; }
.view-btn {
  flex: 1;
  background: linear-gradient(180deg,var(--primary-light),var(--primary));
  color: #fff;
  font-weight: 600;
  padding: 8px;l
  border: none;
  border-radius: 6px;
  cursor: pointer;
}
/* ==== Status Styles ==== */
#statuscontent h3 { margin-top:0; }
#statusSearch { width:100%; padding:8px; border:1px solid var(--border); border-radius:6px; margin:8px 0; }
#statusCountBox { margin-top:10px; font-weight:bold; color:#0077b6; }

/* Sidebar toggle animation */
#sidebar {
  width: 440px;
  transition: transform 0.3s ease;
}
#sidebar.hidden {
  transform: translateX(-100%);
}
#map {
  flex: 1;
  transition: margin-left 0.3s ease;
}
#map.full {
  margin-left: -440px; /* match sidebar width */
}
#toggleSidebar {
  position: fixed;
  top: 130px;            /* vertical position */
  left: 440px;           /* align with sidebar‚Äôs right edge */
  z-index: 1500;
  background: #00a86b;   /* theme color */
  color: #fff;
  border: none;
  border-radius: 0 6px 6px 0;
  padding: 6px 8px;      /* small clickable box */
  cursor: pointer;
  font-size: 14px;       /* smaller arrow */
  width: auto;
  height: auto;
}

#sidebar.hidden + #toggleSidebar {
  left: 0;  /* when sidebar hidden, button hugs screen edge */
}




  
/* Inline radio/label alignment for borehole controls */
.layer-option label { display:flex; align-items:center; gap:8px; cursor:pointer; }
.layer-option input[type="radio"] { width:16px; height:16px; }
.legend#abstractionLegend span { display:inline-block; width:16px; height:16px; margin-right:6px; vertical-align:middle; border:1px solid #999; }
</style>
</head>
<body>
<div id="topbar">
<div>üåç NWRA Groundwater Dashboard</div>
<div style="display:flex;align-items:center;gap:15px;">
<div>
<!-- <span style="font-size:14px;">Total Yield:</span> 
        <strong id="totalYield" style="color:yellow">0</strong> m¬≥ -->
</div>
<img alt="NWRA Logo" src="https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/nwra_logo.png" style="height:45px;width:auto;background-color: white;"/>
</div>
</div>
<button id="toggleSidebar">‚Æú</button>
<div id="container">
<div id="sidebar">
<div class="tabs-container">
<div class="tab active" data-tab="borehole">üíß Borehole</div>
<div class="tab" data-tab="application">Groundwater Abstraction Application</div>
<div class="tab" data-tab="monitor">üìäGround Water Level Monitoring</div>
<div class="tab" data-tab="status">‚ùìMonitoring Status</div>
<div class="tab" data-tab="artesian">‚õ≤ Artesian Wells</div>
<div class="tab" data-tab="aquifer">ü™® Aquifers</div>
<div class="tab" data-tab="geology">üåã Geology</div>
<div class="tab" data-tab="faults">‚ö° Faults and  LULC</div>
<div class="tab" data-tab="rivers">üåä Rivers</div>
<div class="tab" data-tab="qulati">GW-QUALITY</div>
</div>
<div class="tab-content-container">
<!-- Borehole (from saturday.html) -->
<div class="tabContent" id="boreholecontent" style="display:block">
<div id="boreholeSidebar">
<h3>üíß Borehole Data</h3>
<div class="layerToggle">
<label>
<input checked="" id="toggleBoreholes" type="checkbox"/>
    Show Boreholes
  </label>
</div>
<!-- <label><b>Upload Borehole CSV</b></label>  -->
<!-- <input id="boreholeCSV" type="file" accept=".csv">  -->
<input id="searchBox" placeholder="üîç Search borehole by name..." type="text"/>
<div id="countBox">Total Boreholes: 0</div>
<div style="margin-top:15px;">
<b>Color Boreholes By:</b>
<div class="layer-option"><label style="display:flex;align-items:center;gap:8px;"><input name="boreholeLayer" type="radio" value="depth"/> <span>Borehole Depth (m)</span></label></div>
<div class="layer-option"><label style="display:flex;align-items:center;gap:8px;"><input name="boreholeLayer" type="radio" value="swl"/> <span>Static Water Level (mbgl)</span></label></div>
<div class="layer-option"><label style="display:flex;align-items:center;gap:8px;"><input name="boreholeLayer" type="radio" value="yield"/> <span>Yield (l/s)</span></label></div>
<div class="layer-option"><label style="display:flex;align-items:center;gap:8px;"><input name="boreholeLayer" type="radio" value="abstraction"/> <span>Abstraction per day (m¬≥/day)</span></label></div>
<div class="layer-option"><label style="display:flex;align-items:center;gap:8px;"><input name="boreholeLayer" type="radio" value="licenced"/> <span>Licenced (Yes/No/N/A)</span></label></div>

<div style="margin-top:20px;">
<h4>üìä Borehole Distribution</h4>
<canvas id="boreholeChart" style="max-height:220px;"></canvas>
</div>

<!-- Abstraction subcontainer -->
<div id="abstractionContainer" style="margin-top:14px;display:none;">
  <!-- <h4>üü† Abstraction per day</h4> -->
  <canvas id="abstractionChart" style="max-height:220px; margin-top:8px;"></canvas>
</div>

<!-- Licenced subcontainer -->
<div id="licencedContainer" style="margin-top:14px;display:none;">
  <!-- <h4>‚úÖ Licenced?</h4> -->
  <!-- <div style="font-size:12px;margin-top:4px;">Options: Yes | No | N/A</div> -->
  <div style="margin-top:8px;">
    <!-- pie chart for licenced -->
    <canvas id="licencedChart" style="max-height:220px;"></canvas>
  </div>
</div>


</div>
</div>
</div>
<!-- the abstraction application code -->
<div class="tabContent" id="applicationcontent">
<h3>Groundwater Abstraction Applications</h3>
<!-- Upload -->
<label><b>Upload Application CSV</b></label>
<input accept=".csv" id="applicationCSV" type="file"/>
<!-- Toggles -->
<div class="layerToggle">
<label><input checke="" id="toggleApplications" type="checkbox"/> Show Applications</label>
</div>
<!-- Summaries -->
<div id="applicationSummary">Total Applications: 0</div>
<div id="applicationStatusSummary"></div>
<div id="applicationYieldWarning" style="color:red; font-weight:bold; margin-top:10px;"></div>
<!-- Charts -->
<h4>üìä Applications by Status</h4>
<canvas id="applicationStatusChart"></canvas>
<h4>üìä Applications by Purpose</h4>
<canvas id="applicationPurposeChart"></canvas>
<!-- Report download -->
<h4>‚¨áÔ∏è Reports</h4>
<label><b>Filter by District</b></label>
<input id="filterDistrict" placeholder="e.g. Lilongwe" type="text"/>
<label><b>Filter by Status</b></label>
<select id="filterStatus">
<option value="">All</option>
<option value="Approved">Approved</option>
<option value="Pending">Pending</option>
<option value="Rejected">Rejected</option>
</select>
<button id="downloadApplications">Download Filtered Applications (CSV)</button>
<!-- proximity analysis -->
<div class="layerToggle">
<label><input id="toggleProximity" type="checkbox"/> Enable Proximity Analysis</label>
</div>
<div style="margin-top:10px;">
<label><b>Select Buffer Distance</b></label>
<select id="bufferDistance">
<option value="100">100 m</option>
<option value="250">250 m</option>
<option selected="" value="500">500 m</option>
<option value="1000">1 km</option>
</select>
</div>
<div id="proximitySummary" style="margin-top:10px; color:#d9534f; font-weight:bold;"></div>
</div>
<!-- Monitoring -->
<!-- Monitoring Tab -->
<div class="tabContent" id="monitorcontent">
<!-- <label><b>Upload Monitoring CSV</b></label>
  <input id="monitorCSV" type="file" accept=".csv"> -->
<div class="layerToggle">
<label><input id="toggleMonitoring" type="checkbox">
Show Monitoring Stations</label>
</div>
<div class="search-container">
<span class="search-icon">üîç</span>
<input class="search-input" id="stationSearch" placeholder="Search for a station..." type="text"/>
</div>
<label><b>Select Station</b></label>
<select id="stationSelect"></select>
<div class="station-info" id="stationInfo" style="display: none;">
<div class="info-item"><span class="info-label">Station ID</span><span class="info-value" id="info-id">-</span></div>
<div class="info-item"><span class="info-label">Latitude</span><span class="info-value" id="info-lat">-</span></div>
<div class="info-item"><span class="info-label">Longitude</span><span class="info-value" id="info-lon">-</span></div>
<div class="info-item"><span class="info-label">Records</span><span class="info-value" id="info-records">-</span></div>
</div>
<label><b>Download Option</b></label>
<div class="radio-group">
<div class="radio-option">
<input checked="" id="downloadAll" name="downloadOption" type="radio" value="all"/>
<label for="downloadAll">All Wells</label>
</div>
<div class="radio-option">
<input id="downloadSingle" name="downloadOption" type="radio" value="single"/>
<label for="downloadSingle">Single Well</label>
</div>
</div>
<button id="downloadMonitoringData" style="background:var(--secondary);">
    ‚¨áÔ∏è Download Monitoring Data
  </button>
<label><b>Chart Type</b></label>
<select id="chartType">
<option value="line">Line Chart</option>
<option value="bar">Bar Chart</option>
<option value="scatter">Scatter Plot</option>
<option value="box">Box Plot</option>
</select>
<div id="visualization-controls">
<button class="view-btn" id="normalViewBtn">üì± Normal View</button>
<button class="view-btn" id="maximizedViewBtn">üì∫ Maximize</button>
</div>
<div class="chart-container">
<div id="monitorChart" style="height:400px"></div>
<button id="downloadGraph" style="margin-top:15px; background:var(--secondary);">‚¨áÔ∏è Download Graph</button>
</div>
</div>
<!-- Maximized Monitoring Modal -->
<div class="modal" id="maximizedMonitoring" style="display:none;">
<div class="modal-content">
<span class="close" id="closeMaximized">√ó</span>
<h2>üìä Maximized Monitoring View</h2>
<div class="search-container">
<span class="search-icon">üîç</span>
<input class="search-input" id="maxStationSearch" placeholder="Search station..." type="text"/>
</div>
<label><b>Select Station</b></label>
<select id="maxStationSelect"></select>
<label><b>Chart Type</b></label>
<select id="maxChartType">
<option value="line">Line Chart</option>
<option value="bar">Bar Chart</option>
<option value="scatter">Scatter Plot</option>
<option value="box">Box Plot</option>
</select>
<div id="maxMonitorChart" style="height:600px; margin-top:20px;"></div>
<button id="downloadMaxGraph" style="margin-top:15px; background:var(--secondary);">‚¨áÔ∏è Download Graph</button>
</div>
</div>
<!-- Status Tab -->
<div class="tabContent" id="statuscontent">
<h3>Status</h3>
<div class="layerToggle">
<label><input id="toggleStatus" type="checkbox">
 Show Monitoring Status Wells</label>
</div>
<input id="statusSearch" placeholder="üîç Search well by name..." type="text"/>
<!-- <div id="statusCountBox">Totals ‚Üí Good: 0 | Vandalised: 0 | Abandoned: 0</div> -->
<h2 style="font-size: 12px;">GW Monitoring Station Functionatility Status</h2>
<canvas id="statusChart"></canvas>
<div id="statusSummary"></div>
</div>
<div class="tabContent" id="artesiancontent">
<h3>Artesian Wells</h3>
<label>
<input id="toggleArtesian" type="checkbox"/>
    Show Artesian Wells
  </label>
<div id="artesianSummary">Total Artesian Wells: 0</div>
</div>
<!-- Aquifers -->
<div class="tabContent" id="aquifercontent">
<h3>Aquifer Map</h3>
<div class="layerToggle"><label><input checked="" id="toggleAquifers" type="checkbox"/> Show Aquifers</label></div>
<label><input checked="" class="aquiferFilter" type="checkbox" value="Basement Rock"/> Basement Rock</label><br/>
<label><input checked="" class="aquiferFilter" type="checkbox" value="Alluvial Sediment"/> Alluvial Sediment</label><br/>
<label><input checked="" class="aquiferFilter" type="checkbox" value="Weathered Basement"/> Weathered Basement</label><br/>
<div class="summary" id="aquiferSummary">3 categories visible</div>
<button id="downloadAquifer">‚¨áÔ∏è Download Filtered Aquifers</button>
</div>
<!-- Geology -->
<div class="tabContent" id="geologycontent">
<h3>Geological Map</h3>
<div class="layerToggle"><label><input checked="" id="toggleGeology" type="checkbox"/> Show Geology</label></div>
<label><input checked="" class="geoFilter" type="checkbox" value="Lake"/> Lake</label><br/>
<label><input checked="" class="geoFilter" type="checkbox" value="Metamorphic Rocks"/> Metamorphic Rocks</label><br/>
<label><input checked="" class="geoFilter" type="checkbox" value="Magmatic Intrusions"/> Magmatic Intrusions</label><br/>
<label><input checked="" class="geoFilter" type="checkbox" value="Sedimentary Rocks"/> Sedimentary Rocks</label><br/>
<label><input checked="" class="geoFilter" type="checkbox" value="Sediments"/> Sediments</label><br/>
<div class="summary" id="geoSummary">5 categories visible</div>
<button id="downloadGeology">‚¨áÔ∏è Download Filtered Geology</button>
</div>
<!-- Faults -->
<div class="tabContent" id="faultscontent">
<h3>Fault &LULC Map</h3>
<div class="layerToggle"><label><input checked="" id="toggleFaults" type="checkbox"/> Show Faults</label></div>
<p>Fault lines displayed with attributes.</p>
<div class="layerToggle"><label><input id="toggleLULC" type="checkbox"/> Show LULC Layer</label></div>
<label style="display:block;margin-top:6px;"><b>LULC Opacity</b></label>
<input id="lulcOpacity" type="range" min="0" max="1" step="0.05" value="0.7" style="width:100%;margin-bottom:6px;">
<div class="legend" id="lulcLegend" style="margin-top:10px;">
<b>üåç Land Use / Land Cover (LULC) Legend</b><br/>
<div><span style="background:#e06422"></span> Built-up</div>
<div><span style="background:#1ba860"></span>  Tree Plantation</div>
<div><span style="background:#d1ff07"></span>  Agriculture</div>
<div><span style="background:#006400"></span>  Trees</div>
<div><span style="background:#f421ff"></span>  Shrubs</div>
<div><span style="background:#00ffff"></span> Herbaceous</div>
<div><span style="background:#a9a9a9"></span>  Bare Area</div>
<div><span style="background:#2203c2"></span>  Water</div>
</div>
<style>
    #lulcLegend span {
      display:inline-block;
      width:16px;
      height:16px;
      margin-right:6px;
      vertical-align:middle;
      border:1px solid #999;
    }
    </style>


</div>

<!-- Inserted GW‚ÄëQUALITY Tab -->
<div class="tabContent" id="qulaticontent">
<h3>üå°Ô∏è Groundwater Quality</h3>


<label><b>Select Water Quality Parameter</b></label>
<select id="gwQualitySelect">
<option value="">-- choose parameter --</option>
<option value="Turbidity">Turbidity</option>
<option value="Temp">Temperature</option>
<option value="Conductivity">Conductivity</option>
<option value="pH">pH</option>
<option value="Alkalinity">Alkalinity</option>
<option value="Hardness">Hardness</option>
<option value="Calcium">Calcium</option>
<option value="Magnesium">Magnesium</option>
<option value="Sodium">Sodium</option>
<option value="Potassium">Potassium</option>
<option value="Carbonate">Carbonate</option>
<option value="Bicarbonate">Bicarbonat</option>
<option value="Sulphate">Sulphate</option>
<option value="Nitrate">Nitrate</option>
<option value="Ammonium">Ammonium</option>
<option value="Iron">Iron</option>
<option value="Manganese">Manganese</option>
<option value="Flouride">Fluoride</option>
<option value="Chlorine">Chlorine</option>
</select>


<div id="gwQualityLegend" class="legend"></div>
</div>
<div class="tabContent" id="riverscontent">
<h3>Rivers Map</h3>
<div class="layerToggle"><label><input checked="" id="toggleRivers" type="checkbox"/> Show Rivers</label></div>
<p>Rivers lines displayed with attributes.</p>
</div></div>
</div>
<div id="map"></div>

<script>
/* ==== Base Maps ==== */
const baseLayers = {
  "Carto Dark": L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors &copy; <a href="https://carto.com/">CARTO</a>',
    subdomains: 'abcd',
    maxZoom: 20
  }),
  "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }),
  "Google Roadmap": L.tileLayer('http://mt0.google.com/vt/lyrs=m&hl=en&x={x}&y={y}&z={z}', {
    attribution: 'Google'
  }),
  "Google Terrain": L.tileLayer('http://mt0.google.com/vt/lyrs=p&hl=en&x={x}&y={y}&z={z}', {
    attribution: 'Google'
  }),
  "Google Satellite": L.tileLayer('http://mt0.google.com/vt/lyrs=s&hl=en&x={x}&y={y}&z={z}', {
    attribution: 'Google'
  }),
  "Google Hybrid": L.tileLayer('http://mt0.google.com/vt/lyrs=y&hl=en&x={x}&y={y}&z={z}', {
    attribution: 'Google'
  })
};

/* ==== Map Initialization ==== */
const map = L.map('map', {
  center: [-13.9, 33.8],   // Malawi center
  zoom: 7,
  layers: [baseLayers["Carto Dark"]], 
  maxZoom: 20
});



// --- Custom panes for layer order control ---
map.createPane('polygonsPane');  map.getPane('polygonsPane').style.zIndex = 400;
map.createPane('linesPane');     map.getPane('linesPane').style.zIndex = 450;
map.createPane('boreholesPane'); map.getPane('boreholesPane').style.zIndex = 650;
map.createPane('monitorPane');   map.getPane('monitorPane').style.zIndex = 660;
map.createPane('applicationsPane'); map.getPane('applicationsPane').style.zIndex = 670;
map.createPane('statusPane');    map.getPane('statusPane').style.zIndex = 680;
map.createPane('artesianPane');
// === Fix tooltip visibility above all markers ===
map.createPane('tooltipPane');
map.getPane('tooltipPane').style.zIndex = 9999;
L.Tooltip.prototype.options.pane = 'tooltipPane';
  map.getPane('artesianPane').style.zIndex = 690;
/* ==== Layer Control ==== */
L.control.layers(baseLayers).addTo(map);

/* ==== Search restricted to Malawi ==== */
L.Control.geocoder({
  defaultMarkGeocode: true,
  geocoder: L.Control.Geocoder.nominatim({
    geocodingQueryParams: { countrycodes: 'MW' }
  })
}).addTo(map);

/* ==== Tabs ==== */
document.querySelectorAll(".tab").forEach(tab=>{
  tab.addEventListener("click",()=>{
    document.querySelectorAll(".tab").forEach(t=>t.classList.remove("active"));
    document.querySelectorAll(".tabContent").forEach(c=>c.style.display="none");
    tab.classList.add("active");
    document.getElementById(tab.dataset.tab+"content").style.display="block";
  });
});

/* ==== Boreholes (from saturday.html) ==== */
proj4.defs("EPSG:32736", "+proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs");
function convertToLatLon(easting, northing){
  return proj4("EPSG:32736","EPSG:4326",[easting, northing]);
}
// === Borehole Static Data from GitHub ===
let boreholeData = [];
let boreholeMarkers = [];
let markerIndex = {};
let boreholeLayerGroup = L.layerGroup().addTo(map);

// NEW layer groups to ensure consistent toggling & z-order control
let applicationLayerGroup = L.layerGroup().addTo(map);
let artesianLayerGroup = L.layerGroup().addTo(map);



Papa.parse("https://nationalwaterresourcesauthorit-commits.github.io/groundwater-section/boreholedata.csv", {
  download: true,
  header: true,
  dynamicTyping: true,
  complete: function(results) {
    boreholeData = results.data;
    plotBoreholes();
  }
});

// Closing the upload github

function clearMarkers() {
  boreholeLayerGroup.clearLayers();
  boreholeMarkers = [];
  markerIndex = {};
}


function plotBoreholes() {
  clearMarkers();
  const selectedLayer = document.querySelector('input[name="boreholeLayer"]:checked');
  let layerType = selectedLayer ? selectedLayer.value : null;

  boreholeData.forEach(row => {

function isUnknownNumeric(v){
  // treat missing/null as unknown, and specifically 0.00001 as Unknown.
  if(v===null || v===undefined || v==="") return true;
  var n = parseFloat(v);
  if(isNaN(n)) return true;
  if(n === 0.00001) return true; // explicit unknown sentinel
  return false;
}
function parseNumberOrNull(v){
  if(v===null || v===undefined || v==="") return null;
  var n = parseFloat(v);
  if(isNaN(n)) return null;
  return n;
}
function formatPopupValue(v, isNumeric) {
    // User choice: show '-' for empty/blank values
    if (v === null || v === undefined || v === "") return "-";

    if (isNumeric) {
        var num = parseFloat(v);
        if (isNaN(num)) return "-";
        // ONLY treat exact sentinel 0.00001 as Unknown
        if (num === 0.00001) return "Unknown";
        // real zero is valid
        return num;
    }
    // For non-numeric strings, normalize Licenced values
    return v;
}

    if(!row.Easting || !row.Northing) return;
    let [lon,lat] = convertToLatLon(parseFloat(row.Easting), parseFloat(row.Northing));
    if(isNaN(lat)||isNaN(lon)) return;

    let color = 'blue';
    if(layerType==='depth') color = getDepthColor(parseFloat(row["Borehole Depth"]));
    if(layerType==='swl') color = getSWLColor(parseFloat(row["Static Water Level"]));
    if(layerType==='yield') color = getYieldColor(parseFloat(row["Yield l/s"]));
    if(layerType==='abstraction') {
      let a = row["Abstraction Volume per day"];
      color = getAbstractionColor(parseFloat(a));
    }
    if(layerType==='licenced') {
      color = getLicencedColor(row["Licenced"]);
    }
const marker=L.circleMarker([lat,lon], { pane: 'boreholesPane', 
      radius:6,fillColor:color,color:'#333',weight:1,opacity:1,fillOpacity:0.8
    }).addTo(boreholeLayerGroup);

   marker.bindTooltip(`
  <b>Name:</b> ${formatPopupValue(row.Name, false) }<br>
  <b>Grant Number:</b> ${formatPopupValue(row.Grant_Number, false) }<br>
  <b>Driller:</b> ${formatPopupValue(row.Driller, false) }<br>
  <b>Date Drilled:</b> ${formatPopupValue(row["Date Drilled"], false) }<br>
  <b>Abstraction/day:</b> ${formatPopupValue(row["Abstraction Volume per day"], true) }<br>
  <b>District:</b> ${formatPopupValue(row.District, false) }<br>
  <b>Status:</b> ${formatPopupValue(row.Status, false) }<br>
  <b>Functionality:</b> ${formatPopupValue(row.Functionality, false) }<br>
  <b>BH Depth (m):</b> ${formatPopupValue(row["Borehole Depth"], true) }<br>
  <b>SWL (m):</b> ${formatPopupValue(row["Static Water Level"], true) }<br>
  <b>Yield (l/s):</b> ${formatPopupValue(row["Yield l/s"], true) }<br>
  <b>Permanent Casing Diameter:</b> ${formatPopupValue(row["Permanent Casing Diameter"], false) }<br>
  <b>Type of Pump Installed:</b> ${formatPopupValue(row["Type of Pump Installed"], false) }<br>
  <b>Water Point Use:</b> ${formatPopupValue(row["Water Point Use"], false) }<br>
  <b>Licenced:</b> ${formatPopupValue(row["Licenced"], false) }<br>
  <b>Well Development Duration:</b> ${formatPopupValue(row["Well Development Duration"], false) }<br>
  <b>Pump Capacity:</b> ${formatPopupValue(row["Pump Capacity"], false) }<br>
  <b>Pump Installed Depth:</b> ${formatPopupValue(row["Pump Installed Depth"], false) }<br>
  <b>Main Water Strike Depth (MBGL):</b> ${formatPopupValue(row["Main Water Strike Depth (MBGL)"], true) }<br>
  <b>DWL:</b> ${formatPopupValue(row["DWL"], true) }
`);


    boreholeMarkers.push(marker);
    if(row.Name) markerIndex[row.Name.toLowerCase()] = marker;
  });

  updateLegend(layerType);
  document.getElementById("countBox").innerText = `Total Boreholes: ${boreholeData.length}`;

  updateBoreholeChart(layerType);
}

document.querySelectorAll('input[name="boreholeLayer"]').forEach(radio => 
  radio.addEventListener('change', plotBoreholes)
);


// === Borehole Color Functions ===
function getDepthColor(d){
  if (d === null || d === undefined || isNaN(d) ) return "#000000"; // Unknown
  if (d === 0.00001) return "#000000"; // sentinel unknown
  if(d<=10) return "#3288bd";
  if(d<=30) return "#66c2a5";
  if(d<=45) return "#abdda4";
  if(d<=60) return "#e6f598";
  if(d<=80) return "#fee08b";
  return "#f46d43";
}

function getSWLColor(d){
  if (d === null || d === undefined || isNaN(d) ) return "#000000";
  if (d === 0.00001) return "#000000";
  if(d<=5) return "#1a9850";
  if(d<=10) return "#66bd63";
  if(d<=20) return "#a6d96a";
  if(d<=40) return "#fdae61";
  return "#d73027";
}

function getYieldColor(d){
  if (d === null || d === undefined || isNaN(d) ) return "#000000";
  if (d === 0.00001) return "#000000";
  if(d<=0.25) return "#4575b4";
  if(d<=0.5) return "#74add1";
  if(d<=1) return "#abd9e9";
  if(d<=3) return "#fdae61";
  if(d<=5) return "#f46d43";
  return "#d73027";
}

function getAbstractionColor(d){
  if (d === 0.00001) return "#000000";
  if (d === null || d === undefined || isNaN(d)) return "#000000";
  if (d < 10) return "#ffcccc";
  if (d <= 20) return "#ff9999";
  if (d <= 50) return "#ff4d4d";
  if (d > 50) return "#b30000";
  return "#808080";
}
function getLicencedColor(v){
  if(!v) return "#c0c0c0";
  v = v.toString().trim().toLowerCase();
  if(v==="yes") return "#2ca02c";
  if(v==="no") return "#d62728";
  if(v==="n/a"||v==="na") return "#7f7f7f";
  // return "#c0c0c0";
}
// piechart for each category==================================
let boreholeChartInstance = null;
let abstractionChartInstance = null;
let licencedChartInstance = null;


function parseNumberOrNull(v){ if(v===null||v===undefined||v==='') return null; var n=parseFloat(v); return isNaN(n)?null:n; }
function updateBoreholeChart(layerType) {
    
    document.getElementById('abstractionContainer').style.display = (layerType === 'abstraction') ? 'block' : 'none';
    document.getElementById('licencedContainer').style.display = (layerType === 'licenced') ? 'block' : 'none';

  // This function now supports: depth, swl, yield, abstraction, licenced
  const chartCanvas = document.getElementById("boreholeChart");
  const abstractionCanvas = document.getElementById("abstractionChart");
  const licencedCanvas = document.getElementById("licencedChart");
  const chartContainer = chartCanvas ? chartCanvas.parentElement : null;
  if (!chartContainer) return;

  // Show/hide relevant canvases
  if (!layerType) {
    chartContainer.style.display = "none";
    if (boreholeChartInstance) { try { boreholeChartInstance.destroy(); } catch(e){} }
    if (abstractionChartInstance) { try { abstractionChartInstance.destroy(); } catch(e){} }
    if (licencedChartInstance) { try { licencedChartInstance.destroy(); } catch(e){} }
    return;
  } else {
    // hide the main boreholeChart when using the dedicated abstraction or licenced pie charts
    if (layerType === 'abstraction' || layerType === 'licenced') {
      chartContainer.style.display = "none";
    } else {
      chartContainer.style.display = "block";
    }
  }

  if (!boreholeData || !boreholeData.length) {
    if (boreholeChartInstance) { try { boreholeChartInstance.destroy(); } catch(e){} }
    return;
  }

  // helper to parse numbers safely
  function toNum(v){
  if (v === null || v === undefined || v === "") return null;
  var n = parseFloat(v);
  if (isNaN(n)) return null;
  return n;
}

  // Variables for counts/labels/colors
  let counts = {}, labels = [], colors = [];

  if (layerType === "depth") {
    counts = { "Unknown":0,"1-10":0,"10-30":0,"30-45":0,"45-60":0,"60-80":0,">80":0 };
    boreholeData.forEach(r => {
      let d = toNum(r["Borehole Depth"]);
      if (d === null) counts["Unknown"]++;
      else if (d === 0.00001) counts["Unknown"]++;
      else if (d <= 10) counts["1-10"]++;
      else if (d <= 30) counts["10-30"]++;
      else if (d <= 45) counts["30-45"]++;
      else if (d <= 60) counts["45-60"]++;
      else if (d <= 80) counts["60-80"]++;
      else counts[">80"]++;
    });
    labels = Object.keys(counts);
    colors = ["#000000","#3288bd","#66c2a5","#abdda4","#e6f598","#fee08b","#f46d43"];
    drawPie(chartCanvas, labels, Object.values(counts), colors, "Borehole Depth (m)");
  } else if (layerType === "swl") {
    counts = { "Unknown":0,"1-5":0,"5-10":0,"10-20":0,"20-40":0,">40":0 };
    boreholeData.forEach(r => {
      let d = toNum(r["Static Water Level"]);
      if (d === null) counts["Unknown"]++;
      else if (d === 0.00001) counts["Unknown"]++;
      else if (d <= 5) counts["1-5"]++;
      else if (d <= 10) counts["5-10"]++;
      else if (d <= 20) counts["10-20"]++;
      else if (d <= 40) counts["20-40"]++;
      else counts[">40"]++;
    });
    labels = Object.keys(counts);
    colors = ["#000000","#1a9850","#66bd63","#a6d96a","#fdae61","#d73027"];
    drawPie(chartCanvas, labels, Object.values(counts), colors, "Static Water Level (m)");
  } else if (layerType === "yield") {
    counts = { "Unknown":0,"0.1-0.25":0,"0.25-0.5":0,"0.5-1":0,"1-3":0,"3-5":0,">5":0 };
    boreholeData.forEach(r => {
      let d = toNum(r["Yield l/s"]);
      if (d === null) counts["Unknown"]++;
      else if (d === 0.00001) counts["Unknown"]++;
      else if (d <= 0.25) counts["0.1-0.25"]++;
      else if (d <= 0.5) counts["0.25-0.5"]++;
      else if (d <= 1) counts["0.5-1"]++;
      else if (d <= 3) counts["1-3"]++;
      else if (d <= 5) counts["3-5"]++;
      else counts[">5"]++;
    });
    labels = Object.keys(counts);
    colors = ["#000000","#4575b4","#74add1","#abd9e9","#fdae61","#f46d43","#d73027"];
    drawPie(chartCanvas, labels, Object.values(counts), colors, "Yield (l/s)");
  } else if (layerType === "abstraction") {
    // Abstraction ranges: <10, 10-20, 20-50, >50
    counts = { "<10":0, "10-20":0, "20-50":0, ">50":0, "Unknown":0 };
    boreholeData.forEach(r => {
      let d = parseNumberOrNull(r['Abstraction Volume per day']);
      if (d === null) { counts["Unknown"]++; }
      else if (d === 0.00001) { counts["Unknown"]++; }
      else if (d < 10) counts["<10"]++;
      else if (d <= 20) counts["10-20"]++;
      else if (d <= 50) counts["20-50"]++;
      else counts[">50"]++;
    });
    labels = ["<10","10-20","20-50",">50"];
    colors = ["#ffcccc","#ff9999","#ff4d4d","#b30000","#000000"];
    drawPie(abstractionCanvas, labels, labels.map(l=>counts[l]), colors, "Abstraction per day (m¬≥/day)");
   } else if (layerType === "licenced") {
    // Ensure Unknown is explicitly counted
    counts = { "Yes":0, "No":0, "N/A":0};
    boreholeData.forEach(r => {
      let v = (r["Licenced"] || "").toString().trim();
      if (!v) counts["Unknown"]++;
      else if (/^yes$/i.test(v)) counts["Yes"]++;
      else if (/^no$/i.test(v)) counts["No"]++;
      else if (/^n\/a$/i.test(v) || /^na$/i.test(v) || /^n a$/i.test(v)) counts["N/A"]++;
    });
    // Keep a stable label order and matching colors
    labels = ["Yes","No","N/A"];
    colors = ["#2ca02c","#d62728","#7f7f7f"];
    drawPie(licencedCanvas, labels, labels.map(l=>counts[l]), colors, "Licenced");
  }

  // helper to draw pie charts to a canvas element and manage instances
  function drawPie(canvasEl, labels, dataArr, colorsArr, titleText) {
    // destroy instances if exist for respective canvases
    try { if (canvasEl === chartCanvas && boreholeChartInstance) boreholeChartInstance.destroy(); } catch(e){}
    try { if (canvasEl === abstractionCanvas && abstractionChartInstance) abstractionChartInstance.destroy(); } catch(e){}
    try { if (canvasEl === licencedCanvas && licencedChartInstance) licencedChartInstance.destroy(); } catch(e){}

    var ctx = canvasEl.getContext("2d");
    var cfg = {
      type: "pie",
      data: { labels: labels, datasets: [{ data: dataArr, backgroundColor: colorsArr }] },
      options: { responsive: true, plugins: { legend: { position: "bottom" }, title: { display: true, text: titleText } } }
    };
    var instance = new Chart(ctx, cfg);
    if (canvasEl === chartCanvas) boreholeChartInstance = instance;
    if (canvasEl === abstractionCanvas) abstractionChartInstance = instance;
    if (canvasEl === licencedCanvas) licencedChartInstance = instance;
  }
}

// declare global variable for legend handling
let activeLegend = null;

function updateLegend(layerType){
  if(activeLegend){ map.removeControl(activeLegend); activeLegend=null; }
  if(!layerType) return;
  activeLegend=L.control({position:'bottomright'});
  activeLegend.onAdd=function(){
    let div=L.DomUtil.create('div','legend');
    if(layerType==='depth'){ div.innerHTML='<b>Borehole Depth (m)</b><br><i style="background:#000000"></i>Unknown<br><br><i style="background:#3288bd"></i>1-10<br>   <i style="background:#66c2a5"></i>10-30<br><i style="background:#abdda4"></i>30-45<br><i style="background:#e6f598"></i>45-60<br><i style="background:#fee08b"></i>60-80<br><i style="background:#f46d43"></i>>80'; }
    else if(layerType==='swl'){ div.innerHTML='<b>Static Water Level (m)</b><br><i style="background:#000000"></i>Unknown<br><br><i style="background:#1a9850"></i>1-5<br><i style="background:#66bd63"></i>5-10<br><i style="background:#a6d96a"></i>10-20<br><i style="background:#fdae61"></i>20-40<br><i style="background:#d73027"></i>>40'; }
    else if(layerType==='yield'){ div.innerHTML='<b>Yield (l/s)</b><br><i style="background:#000000"></i>Unknown<br><br><i style="background:#4575b4"></i>0.1-0.25<br><i style="background:#74add1"></i>0.25-0.5<br><i style="background:#abd9e9"></i>0.5-1<br><i style="background:#fdae61"></i>1-3<br><i style="background:#f46d43"></i>3-5<br><i style="background:#d73027"></i>>5'; }
    else if(layerType==='abstraction'){
    div.innerHTML='<b>Abstraction (m¬≥/day)</b><br>' +
    '<i style="background:#ffcccc"></i>&lt;10<br>' +
    '<i style="background:#ff9999"></i>10-20<br>' +
    '<i style="background:#ff4d4d"></i>20-50<br>' +
    '<i style="background:#b30000"></i>&gt;50<br>' +
    '<i style="background:#000000"></i>Unknown';
  }
    else if(layerType==='licenced'){ div.innerHTML='<b>Licenced</b><br><i style="background:#2ca02c"></i>Yes<br><i style="background:#d62728"></i>No<br><i style="background:#7f7f7f"></i>N/A<br>'; }
    return div;
  }
  activeLegend.addTo(map);
}
// document.getElementById('boreholedata.csv').addEventListener('change', function(e) {
//   const fileInput = e.target;
//   const file = fileInput.files[0];
//   if (!file) return;

//   const entered = prompt("Enter password to upload Borehole CSV:");
//   if (entered !== "NWRA2025") {   // üîë change password here
//     alert("‚ùå Incorrect password! Upload cancelled.");
//     fileInput.value = ""; // clear selection
//     return;
//   }

//   Papa.parse(file, {
//     header: true,
//     dynamicTyping: true,
//     complete: function(results) {
//       boreholeData = results.data;
//       plotBoreholes();
//     }
//   });
// });
// Papa.parse("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/boreholedata.csv", {
//   download: true,
//   header: true,
//   dynamicTyping: true,
//   complete: function(results) {
//     boreholeData = results.data;
//     plotBoreholes();  // plot immediately
//   }
// });



document.querySelectorAll('input[name="boreholeLayer"]').forEach(radio=>radio.addEventListener('change',plotBoreholes));

document.getElementById("toggleBoreholes").addEventListener("change", e => {
  if (e.target.checked) {
    map.addLayer(boreholeLayerGroup);
    plotBoreholes();
  } else {
    map.removeLayer(boreholeLayerGroup);
    if (activeLegend) {
      map.removeControl(activeLegend);
      activeLegend = null;
    }
  }
});

document.getElementById("searchBox").addEventListener("keyup",function(e){
  if(e.key==="Enter"){
    let query=e.target.value.trim().toLowerCase();
    if(query&&markerIndex[query]){ let marker=markerIndex[query]; map.setView(marker.getLatLng(),14); marker.openTooltip(); }
    else alert("Borehole not found!");
  }
});

/* ==== Legends for Aquifer/Geology/Faults ==== */
const legendControl = L.control({position:"bottomright"});
legendControl.onAdd = function(map){
  this._div = L.DomUtil.create("div","legend");
  this.update();
  return this._div;
};
legendControl.update = function(content=""){ this._div.innerHTML = content; };
legendControl.addTo(map);

function showLegend(type){
  let html = "<b>"+type+" Legend</b><br>";
  if(type==="Aquifers"){
    html += '<div><span style="background:#1f78b4"></span> Basement Rock</div>';
    html += '<div><span style="background:#33a02c"></span> Alluvial Sediment</div>';
    html += '<div><span style="background:#ff7f00"></span> Weathered Basement</div>';
  } else if(type==="Geology"){
    html += '<div><span style="background:#1f78b4"></span> Lake</div>';
    html += '<div><span style="background:#6a3d9a"></span> Metamorphic Rocks</div>';
    html += '<div><span style="background:#e31a1c"></span> Magmatic Intrusions</div>';
    html += '<div><span style="background:#ff7f00"></span> Sedimentary Rocks</div>';
    html += '<div><span style="background:#33a02c"></span> Sediments</div>';
  } else if(type==="Faults"){
    html += '<div><span style="background:#000;border:1px dashed #000;width:20px;height:2px;display:inline-block;margin-right:6px;"></span> Faults</div>';
  }else if(type==="Rivers"){
  html += '<div><span style="background:#1f78b4;width:20px;height:2px;display:inline-block;margin-right:6px;"></span> Rivers</div>';
}
  
  legendControl.update(html);
}
function clearLegend(){ legendControl.update(""); }

/* ==== Aquifers ==== */
let aquiferLayer;
fetch("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/aquifer.geojson")
  .then(r=>r.json()).then(geojson=>{
    aquiferLayer = L.geoJSON(geojson, {
      style:f=>{
        let c="#999";
        if(f.properties.AQ_Class==="Basement Rock")c="#1f78b4";
        if(f.properties.AQ_Class==="Alluvial Sediment")c="#33a02c";
        if(f.properties.AQ_Class==="Weathered Basement")c="#ff7f00";
        return{color:c,weight:0.7,fillOpacity:0.5};
      },
      onEachFeature:(f,l)=>{
        l.bindPopup(`Aquifer: ${f.properties.AQ_Class}`);
        l.on("mouseover",()=>l.setStyle({weight:2}));
        l.on("mouseout",()=>l.setStyle({weight:0.7}));
      }
    , pane: 'polygonsPane'}).addTo(map);
    showLegend("Aquifers");
  });

function updateAquifers(){
  const selected = Array.from(document.querySelectorAll(".aquiferFilter:checked")).map(x=>x.value);
  aquiferLayer.eachLayer(l=>{
    const aq = l.feature.properties.AQ_Class;
    l.setStyle({fillOpacity: selected.includes(aq)?0.5:0});
  });
  document.getElementById("aquiferSummary").innerText = `${selected.length} categories visible`;
}
document.querySelectorAll(".aquiferFilter").forEach(cb=>cb.addEventListener("change",updateAquifers));
document.getElementById("toggleAquifers").addEventListener("change",e=>{
  if(e.target.checked){ map.addLayer(aquiferLayer); showLegend("Aquifers"); }
  else{ map.removeLayer(aquiferLayer); clearLegend(); }
});

/* ==== Geology ==== */
let geologyLayer;
fetch("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/geology.geojson")
  .then(r=>r.json()).then(geojson=>{
    geologyLayer = L.geoJSON(geojson, {
      style:f=>{
        let c="#ccc";
        if(f.properties.Category==="Lake")c="#1f78b4";
        if(f.properties.Category==="Metamorphic Rocks")c="#6a3d9a";
        if(f.properties.Category==="Magmatic Intrusions")c="#e31a1c";
        if(f.properties.Category==="Sedimentary Rocks")c="#ff7f00";
        if(f.properties.Category==="Sediments")c="#33a02c";
        return{color:c,weight:0.7,fillOpacity:0.6};
      },
      onEachFeature:(f,l)=>{
        l.bindPopup(`Geology: ${f.properties.Category}`);
        l.on("mouseover",()=>l.setStyle({weight:2}));
        l.on("mouseout",()=>l.setStyle({weight:0.7}));
      }
    , pane: 'polygonsPane'}).addTo(map);
  });

function updateGeology(){
  const selected = Array.from(document.querySelectorAll(".geoFilter:checked")).map(x=>x.value);
  geologyLayer.eachLayer(l=>{
    const cat = l.feature.properties.Category;
    l.setStyle({fillOpacity: selected.includes(cat)?0.6:0});
  });
  document.getElementById("geoSummary").innerText = `${selected.length} categories visible`;
}
document.querySelectorAll(".geoFilter").forEach(cb=>cb.addEventListener("change",updateGeology));
document.getElementById("toggleGeology").addEventListener("change",e=>{
  if(e.target.checked){ map.addLayer(geologyLayer); showLegend("Geology"); }
  else{ map.removeLayer(geologyLayer); clearLegend(); }
});

/* ==== Faults ==== */
let faultsLayer;
fetch("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/faults.geojson")
  .then(r=>r.json()).then(geojson=>{
    faultsLayer = L.geoJSON(geojson, {
      style:{color:"#000",weight:0.7,dashArray:"5,5"},
      onEachFeature:(f,l)=>l.bindPopup(`Fault: ${f.properties.Name||"N/A"}`)
    , pane: 'polygonsPane'}).addTo(map);
  });
document.getElementById("toggleFaults").addEventListener("change",e=>{
  if(e.target.checked){ map.addLayer(faultsLayer); showLegend("Faults"); }
  else{ map.removeLayer(faultsLayer); clearLegend(); }
});


/* ==== LULC (Earth Engine Layer) ==== */
let lulcLayer = L.tileLayer(
  'https://earthengine.googleapis.com/v1/projects/ee-gis-021-20/maps/4d8dabcf783c6878cc82e557c95f5a4a-17faa5ac02196919a732e85f694facb8/tiles/{z}/{x}/{y}',
  {
    attribution: "Google Earth Engine | NWRA",
    opacity: 0.7,
    pane: 'polygonsPane'
  }
);


const toggleLULCEl = document.getElementById("toggleLULC");
if (toggleLULCEl) {
  toggleLULCEl.addEventListener("change", (e) => {
    if (e.target.checked) {
      map.addLayer(lulcLayer);
    } else {
      map.removeLayer(lulcLayer);
    }
  });
}


/* ==== Rivers ==== */
let riversLayer;
fetch("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/riverss.geojson")
  .then(r=>r.json()).then(geojson=>{
    // assign to the correct variable (riversLayer)
    riversLayer = L.geoJSON(geojson, {
      style:{color:"#1f78b4",weight:2},
      onEachFeature:(f,l)=>l.bindPopup(`River: ${f.properties.Name||"N/A"}`)
    , pane: 'polygonsPane'}).addTo(map);
  });

// safe check before adding listener (element exists in corrected HTML)
const toggleRiversEl = document.getElementById("toggleRivers");
if(toggleRiversEl){
  toggleRiversEl.addEventListener("change",e=>{
    if(!riversLayer) return; // data might not be loaded yet
    if(e.target.checked){ map.addLayer(riversLayer); showLegend("Rivers"); }
    else{ map.removeLayer(riversLayer); clearLegend(); }
  });
}

/* ==== Download Functions ==== */
function downloadJSON(data, filename){
  const blob = new Blob([JSON.stringify(data)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  a.click(); URL.revokeObjectURL(url);
}
document.getElementById("downloadAquifer").addEventListener("click",()=>{
  const entered = prompt("Enter password to download:");
  if (entered !== "NWRA2025") {
    alert("‚ùå Incorrect password! Download cancelled.");
    return;
  }

  const selected = Array.from(document.querySelectorAll(".aquiferFilter:checked")).map(x=>x.value);
  const features = [];
  aquiferLayer.eachLayer(l=>{
    if(selected.includes(l.feature.properties.AQ_Class)) features.push(l.feature);
  });
  downloadJSON({type:"FeatureCollection",features}, "filtered_aquifers.geojson");
});
document.getElementById("downloadGeology").addEventListener("click",()=>{
  const entered = prompt("Enter password to download:");
  if (entered !== "NWRA2025") {
    alert("‚ùå Incorrect password! Download cancelled.");
    return;
  }

  const selected = Array.from(document.querySelectorAll(".geoFilter:checked")).map(x=>x.value);
  const features = [];
  geologyLayer.eachLayer(l=>{
    if(selected.includes(l.feature.properties.Category)) features.push(l.feature);
  });
  downloadJSON({type:"FeatureCollection",features}, "filtered_geology.geojson");
});



/* ==== Monitoring Data Handling ==== */

// === Monitoring Static Data from GitHub ===
let monitorData = {};
let monitorLayerGroup = L.layerGroup().addTo(map);
let monitorStations = {};
let monitoringCSVData = null;

Papa.parse("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/malawi_monitoring_large.csv", {
  download: true,
  header: true,
  dynamicTyping: true,
  complete: (res) => {
    monitorData = {}; monitorStations = {}; monitoringCSVData = res.data;

    res.data.forEach(r => {
      if (!r.station || !r.month || !r.year || !r.value) return;

      if (!monitorData[r.station]) {
        monitorData[r.station] = [];
        monitorStations[r.station] = { id: r.station, lat: r.latitude, lon: r.longitude, records: 0 };
      }

      const monthMap = {
        "January":0,"February":1,"March":2,"April":3,"May":4,"June":5,
        "July":6,"August":7,"September":8,"October":9,"November":10,"December":11
      };
      let monthIndex = monthMap[r.month] ?? 0;
      let date = new Date(r.year, monthIndex, 1);

      monitorData[r.station].push({ x: date, y: r.value });
      monitorStations[r.station].records++;
      if (r.latitude && r.longitude) {
        const m = L.circleMarker([parseFloat(r.latitude), parseFloat(r.longitude)], { pane: 'monitorPane', 
          radius: 5, fillColor: '#FFC0CB', color: '#000', weight: 1, opacity: 1, fillOpacity: 0.8
        }).bindTooltip(`Station: ${r.station}`);
        m.addTo(monitorLayerGroup);
      }

    });

    updateStationSelect(); 
    updateMaximizedStationSelect();
  }
});


function updateStationSelect() {
  const sel = document.getElementById("stationSelect");
  const searchTerm = document.getElementById("stationSearch").value.toLowerCase();
  sel.innerHTML = "";
  Object.keys(monitorData).filter(s => s.toLowerCase().includes(searchTerm)).forEach(s => {
    let opt = document.createElement("option"); opt.value = s; opt.textContent = s; sel.appendChild(opt);
  });
  if (sel.options.length > 0) { sel.selectedIndex = 0; plotMonitor(); updateStationInfo(sel.value); }
}
document.getElementById("stationSearch").addEventListener("input", updateStationSelect);

function updateStationInfo(st) {
  const info = monitorStations[st];
  if (info) {
    document.getElementById("stationInfo").style.display = "grid";
    document.getElementById("info-id").textContent = info.id;
    document.getElementById("info-lat").textContent = info.lat ? info.lat.toFixed(4) : "-";
    document.getElementById("info-lon").textContent = info.lon ? info.lon.toFixed(4) : "-";
    document.getElementById("info-records").textContent = info.records;
  } else { document.getElementById("stationInfo").style.display = "none"; }
}

function plotMonitor() {
  const st = document.getElementById("stationSelect").value;
  const type = document.getElementById("chartType").value;
  if (!st || !monitorData[st]) return;

  const sorted = [...monitorData[st]].sort((a,b)=>a.x - b.x);

  let trace = {
    x: sorted.map(d=>d.x),
    y: sorted.map(d=>d.y),
    type: type==='box'?'box':type,
    mode: type==="scatter"?"markers":"lines+markers",
    marker:{size:10,color:"#0082c8"},
    line:{width:3,color:"#0082c8"},
    name: st
  };

  Plotly.newPlot("monitorChart",[trace],{
    title:`Monitoring - ${st}`,
    xaxis:{ title:"Date", type:"date" },
    yaxis:{ title:"Value" }
  });
}
document.getElementById("stationSelect").addEventListener("change",()=>{plotMonitor(); updateStationInfo(document.getElementById("stationSelect").value);});
document.getElementById("chartType").addEventListener("change",plotMonitor);


document.getElementById("toggleMonitoring").addEventListener("change", e => {
  if (e.target.checked) {
    map.addLayer(monitorLayerGroup);
  } else {
    map.removeLayer(monitorLayerGroup);
  }
});


document.getElementById("downloadMonitoringData").addEventListener("click", () => {
  const entered = prompt("Enter password to download:");
  if (entered !== "NWRA2025") {
    alert("‚ùå Incorrect password! Download cancelled.");
    return;
  }

  if (!monitoringCSVData?.length) return alert("No monitoring data available.");
  let dataToDownload = monitoringCSVData;
  if (document.querySelector('input[name="downloadOption"]:checked').value === "single") {
    const st = document.getElementById("stationSelect").value;
    dataToDownload = monitoringCSVData.filter(r=>r.station===st);
  }
  const headers = Object.keys(dataToDownload[0]);
  const csvRows = [headers.join(',')];
  dataToDownload.forEach(r=>csvRows.push(headers.map(h=>`"${r[h]||''}"`).join(',')));
  const blob = new Blob([csvRows.join('\n')],{type:'text/csv'}); const url=URL.createObjectURL(blob);
  const link=document.createElement('a'); link.href=url; link.download='monitoring_data.csv'; link.click();
});
document.getElementById("downloadGraph").addEventListener("click",()=>{
  const entered = prompt("Enter password to download:");
  if (entered !== "NWRA2025") {
    alert("‚ùå Incorrect password! Download cancelled.");
    return;
  }
Plotly.downloadImage("monitorChart",{format:"png",filename:"monitoring_graph"});});

/* ==== Maximized View ==== */
const modal = document.getElementById("maximizedMonitoring");
document.getElementById("maximizedViewBtn").addEventListener("click",()=>{modal.style.display="block"; updateMaximizedStationSelect();});
document.getElementById("closeMaximized").addEventListener("click",()=>modal.style.display="none");
window.addEventListener("click",(e)=>{if(e.target==modal) modal.style.display="none";});

function updateMaximizedStationSelect() {
  const sel = document.getElementById("maxStationSelect");
  const searchTerm = document.getElementById("maxStationSearch").value.toLowerCase();
  sel.innerHTML = "";
  Object.keys(monitorData).filter(s=>s.toLowerCase().includes(searchTerm)).forEach(s=>{
    let opt=document.createElement("option"); opt.value=s; opt.textContent=s; sel.appendChild(opt);
  });
  if (sel.options.length > 0) { sel.selectedIndex=0; plotMaxMonitor(); }
}
document.getElementById("maxStationSearch").addEventListener("input",updateMaximizedStationSelect);
document.getElementById("maxStationSelect").addEventListener("change",plotMaxMonitor);
document.getElementById("maxChartType").addEventListener("change",plotMaxMonitor);

function plotMaxMonitor() {
  const st = document.getElementById("maxStationSelect").value;
  const type = document.getElementById("maxChartType").value;
  if (!st || !monitorData[st]) return;

  const sorted = [...monitorData[st]].sort((a,b)=>a.x - b.x);

  let trace = {
    x: sorted.map(d=>d.x),
    y: sorted.map(d=>d.y),
    type: type==='box'?'box':type,
    mode: type==="scatter"?"markers":"lines+markers",
    marker:{size:10,color:"#0082c8"},
    line:{width:3,color:"#0082c8"},
    name: st
  };

  Plotly.newPlot("maxMonitorChart",[trace],{
    title:`Monitoring - ${st}`,
    xaxis:{ title:"Date", type:"date" },
    yaxis:{ title:"Value" }
  });
}
document.getElementById("downloadMaxGraph").addEventListener("click",()=>{
  const entered = prompt("Enter password to download:");
  if (entered !== "NWRA2025") {
    alert("‚ùå Incorrect password! Download cancelled.");
    return;
  }
Plotly.downloadImage("maxMonitorChart",{format:"png",filename:"monitoring_graph_max"});});

/* ==== Status Wells ==== */
let statusData = [];
let statusMarkers = [];
let statusMarkerIndex = {};
let statusLegend = null;
let statusLayerGroup = L.layerGroup().addTo(map);

function getConditionColor(cond){
  const c = cond ? cond.toLowerCase().trim() : "";
  if(c==="good") return "yellow";
  if(c==="vandalised") return "red";
  if(c==="abandoned") return "black";
  return "gray";
}

function loadStatusData() {
  Papa.parse("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/monitoring_status_data.csv", {
    download: true,
    header: true,
    complete: function(res) {
      statusData = res.data.filter(r => r["Easting "] && r["Northing"]);
      plotStatusWells();
    }
  });
}

function clearStatusMarkers(){
  statusLayerGroup.clearLayers();
  statusMarkers = [];
  statusMarkerIndex = {};
}

function plotStatusWells() {
  clearStatusMarkers();
  let counts = { good:0, vandalised:0, abandoned:0 };

  statusData.forEach(row=>{
    let [lon,lat] = convertToLatLon(parseFloat(row["Easting "]), parseFloat(row["Northing"]));
    if(isNaN(lat)||isNaN(lon)) return;
    const cond = row["Condition"] ? row["Condition"].trim() : "Unknown";
    const color = getConditionColor(cond);

    if(cond.toLowerCase()==="good") counts.good++;
    else if(cond.toLowerCase()==="vandalised") counts.vandalised++;
    else if(cond.toLowerCase()==="abandoned") counts.abandoned++;

    const marker = L.circleMarker([lat,lon], { pane: 'statusPane', 
      radius:6,
      fillColor:color,
      color:'#333',
      weight:1,
      opacity:1,
      fillOpacity:0.8
    });
    marker.bindTooltip(`
      <b>Well:</b> ${row["Groundwater Monitoring Well"]||"-"}<br>
      <b>District:</b> ${row.District||"-"}<br>
      <b>Region:</b> ${row.Region||"-"}<br>
      <b>Easting:</b> ${row["Easting "]||"-"}<br>
      <b>Northing:</b> ${row.Northing||"-"}<br>
      <b>Condition:</b> ${cond}
    `);
    marker.addTo(statusLayerGroup);
    statusMarkers.push(marker);

    if(row["Groundwater Monitoring Well"]) {
      statusMarkerIndex[row["Groundwater Monitoring Well"].toLowerCase()] = marker;
    }
  });

  document.getElementById("CondCountBox").innerText =
    `Totals ‚Üí Good: ${counts.good} | Vandalised: ${counts.vandalised} | Abandoned: ${counts.abandoned}`;

  updateStatusLegend();
}

// coming up with a pie chart 
async function loadMonitoringStatus() {
    const url = "https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/monitoring_status_data.csv";

    const response = await fetch(url);
    const csvText = await response.text();

    // Parse CSV
    const rows = Papa.parse(csvText, { header: true }).data;

    // Count by Condition
    let counts = { "Good": 0, "Vandalised": 0, "abandoned": 0 };

    rows.forEach(r => {
      let c = r.Condition ? r.Condition.trim() : "";
      if (c in counts) {
        counts[c]++;
      }
    });

    // Update summary
    document.getElementById("statusSummary").innerHTML = `
      <h3>Summary</h3>
      <ul>
        <li>Good: ${counts["Good"]}</li>
        <li>Vandalised: ${counts["Vandalised"]}</li>
        <li>Abandoned: ${counts["abandoned"]}</li>
      </ul>
    `;

    // Draw Pie Chart
    const ctx = document.getElementById("statusChart").getContext("2d");
    new Chart(ctx, {
      type: "pie",
      data: {
        labels: ["Good", "Vandalised", "Abandoned"],
        datasets: [{
          data: [counts["Good"], counts["Vandalised"], counts["abandoned"]],
          backgroundColor: ["yellow", "red", "black"]
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { position: "bottom" }
        }
      }
    });
  }

  // Call function when Monitoring tab loads
  document.addEventListener("DOMContentLoaded", loadMonitoringStatus);

function updateStatusLegend(){
  if(statusLegend){ map.removeControl(statusLegend); statusLegend=null; }
  statusLegend = L.control({position:'bottomright'});
  statusLegend.onAdd = function(){
    let div = L.DomUtil.create('div','legend');
    div.innerHTML = `
      <b>Status Legend</b><br>
      <i style="background:blue"></i> Good<br>
      <i style="background:red"></i> Vandalised<br>
      <i style="background:black"></i> Abandoned
    `;
    return div;
  }
  statusLegend.addTo(map);
}

/* ==== Search Well ==== */
document.getElementById("statusSearch").addEventListener("keyup",function(e){
  if(e.key==="Enter"){
    let query=e.target.value.trim().toLowerCase();
    if(query && statusMarkerIndex[query]){
      let marker = statusMarkerIndex[query];
      map.setView(marker.getLatLng(),14);
      marker.openTooltip();
    } else {
      alert("Well not found!");
    }
  }
});


document.getElementById("toggleStatus").addEventListener("change", e => {
  if (e.target.checked) {
    map.addLayer(statusLayerGroup);
    plotStatusWells();
  } else {
    map.removeLayer(statusLayerGroup);
    if (statusLegend) {
      map.removeControl(statusLegend);
      statusLegend = null;
    }
  }
});


/* Load status wells on startup */
loadStatusData();

//ARTESIAN WELL CODE
let artesianData = [];
let artesianMarkers = [];

Papa.parse("https://raw.githubusercontent.com/naturalwaterresourcesauthority-del/dashboard/main/Artesian_Well.csv", {
  download: true,
  header: true,
  dynamicTyping: true,
  complete: function(results) {
    artesianData = results.data;
    document.getElementById("artesianSummary").innerText = `Total Artesian Wells: ${artesianData.length}`;
  }
});

function plotArtesian() {
  artesianData.forEach(row => {
    if(!row.Eastings || !row.Northing) return;
    let [lon, lat] = convertToLatLon(parseFloat(row.Eastings), parseFloat(row.Northing));
    if(isNaN(lat) || isNaN(lon)) return;
    const marker = L.circleMarker([lat, lon], { pane: 'artesianPane',
      radius: 6,
      fillColor: '#40E0D0',
      color: '#000',
      weight: 1,
      opacity: 1,
      fillOpacity: 0.8
    });
    marker.bindTooltip(
      `<b>Name:</b> ${row['Name of Artesian well']||'-'}<br>
       <b>District:</b> ${row.District||'-'}<br>
       <b>TA:</b> ${row['Traditional Authority']||'-'}`
    );
    artesianMarkers.push(marker); marker.addTo(artesianLayerGroup);
  });
}

document.getElementById("toggleArtesian").addEventListener("change", function(e) {
  if(e.target.checked) {
    plotArtesian();
    artesianMarkers.forEach(m => m.addTo(map));
  } else {
    artesianMarkers.forEach(m => map.removeLayer(m));
  }
});




// Sidebar toggle
const sidebar = document.getElementById("sidebar");
const mapDiv = document.getElementById("map");
const toggleBtn = document.getElementById("toggleSidebar");

toggleBtn.addEventListener("click", () => {
  sidebar.classList.toggle("hidden");
  mapDiv.classList.toggle("full");

  // Flip the arrow symbol
  if (sidebar.classList.contains("hidden")) {
    toggleBtn.textContent = "‚Æû"; // expand
    toggleBtn.style.left = "0px";  // hug the screen edge
  } else {
    toggleBtn.textContent = "‚Æú"; // collapse
    toggleBtn.style.left = "440px"; // align with sidebar width
  }

  setTimeout(() => map.invalidateSize(), 310); // resize map
});


/* ==== Groundwater Abstraction Applications ==== */
let applicationData = [];
let applicationMarkers = [];


document.getElementById("toggleApplications").addEventListener("change", e => {
  if (e.target.checked) {
    if (!map.hasLayer(applicationLayerGroup)) map.addLayer(applicationLayerGroup);
    // bring applications pane to front while active
    setPaneZIndex('applicationsPane', 800);
  } else {
    if (map.hasLayer(applicationLayerGroup)) map.removeLayer(applicationLayerGroup);
    // restore default zIndex
    setPaneZIndex('applicationsPane', 670);
  }
});


document.getElementById("applicationCSV").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;

  Papa.parse(file, {
    header: true,
    dynamicTyping: true,
    complete: function(results) {
      applicationData = results.data.filter(r => r.Easting && r.Northing);
      plotApplications();
    }
  });
});

function plotApplications() {
  // clear old markers
  applicationMarkers.forEach(m => map.removeLayer(m));
  applicationMarkers = [];

  applicationData.forEach(row => {
    let [lon, lat] = convertToLatLon(parseFloat(row.Easting), parseFloat(row.Northing));
    if (isNaN(lat) || isNaN(lon)) return;

    const marker = L.circleMarker([lat, lon], {
      pane: 'applicationsPane',
      radius: 7,
      fillColor: "#ff9800",
      color: "#333",
      weight: 1,
      opacity: 1,
      fillOpacity: 0.85
    }).addTo(applicationLayerGroup);

    marker.bindTooltip(`
      <b>Village:</b> ${row.Village || "-"}<br>
      <b>District:</b> ${row.District || "-"}<br>
      <b>Easting:</b> ${row.Easting}<br>
      <b>Northing:</b> ${row.Northing}<br>
      <b>Proposed Volume:</b> ${row["Proposed Abstraction Volumes (m3 per day)"] || "-"} m¬≥/day<br>
      <b>Purpose:</b> ${row["Purpose of the borehole"] || "-"}
    `);

    applicationMarkers.push(marker);
  });

  document.getElementById("applicationSummary").innerText =
    `Total Applications: ${applicationData.length}`;
}

// new additions to the applications 
let applicationChartStatus = null;
let applicationChartPurpose = null;

function plotApplications() {
  applicationMarkers.forEach(m => map.removeLayer(m));
  applicationMarkers = [];

  let totalVolume = 0;
  let statusCounts = { "Approved": 0, "Pending": 0, "Rejected": 0 };
  let purposeCounts = {};

  applicationData.forEach(row => {
    let [lon, lat] = convertToLatLon(parseFloat(row.Easting), parseFloat(row.Northing));
    if (isNaN(lat) || isNaN(lon)) return;

    // Status color
    let status = row.Status || "Pending";
    let color = status === "Approved" ? "green" : status === "Rejected" ? "red" : "orange";

    // Proposed volume
    let volume = parseFloat(row["Proposed Abstraction Volumes (m3 per day)"]) || 0;
    totalVolume += volume;

    // Purpose grouping
    let purpose = row["Purpose of the borehole"] || "Other";
    if (!purposeCounts[purpose]) purposeCounts[purpose] = 0;
    purposeCounts[purpose]++;

    // Marker
    const marker = L.circleMarker([lat, lon], {
      radius: 7,
      fillColor: color,
      color: "#333",
      weight: 1,
      opacity: 1,
      fillOpacity: 0.85
    }).addTo(map);

    marker.bindTooltip(`
      <b>Village:</b> ${row.Village || "-"}<br>
      <b>District:</b> ${row.District || "-"}<br>
      <b>Proposed Volume:</b> ${volume} m¬≥/day<br>
      <b>Purpose:</b> ${purpose}<br>
      <b>Status:</b> ${status}
    `);

    applicationMarkers.push(marker);

    if (statusCounts[status] !== undefined) statusCounts[status]++;
  });

  // Summary
  document.getElementById("applicationSummary").innerText = `Total Applications: ${applicationData.length}`;
  document.getElementById("applicationStatusSummary").innerText =
    `Approved: ${statusCounts.Approved} | Pending: ${statusCounts.Pending} | Rejected: ${statusCounts.Rejected}`;

  // Yield warning (example threshold 50,000 m¬≥/day)
  if (totalVolume > 50000) {
    document.getElementById("applicationYieldWarning").innerText =
      `‚ö†Ô∏è Warning: Total proposed volume (${totalVolume} m¬≥/day) exceeds sustainable threshold!`;
  } else {
    document.getElementById("applicationYieldWarning").innerText = "";
  }

  // Status Pie Chart
  if (applicationChartStatus) applicationChartStatus.destroy();
  applicationChartStatus = new Chart(document.getElementById("applicationStatusChart"), {
    type: "pie",
    data: {
      labels: Object.keys(statusCounts),
      datasets: [{ data: Object.values(statusCounts), backgroundColor: ["green", "orange", "red"] }]
    }
  });

  // Purpose Bar Chart
  if (applicationChartPurpose) applicationChartPurpose.destroy();
  applicationChartPurpose = new Chart(document.getElementById("applicationPurposeChart"), {
    type: "bar",
    data: {
      labels: Object.keys(purposeCounts),
      datasets: [{ label: "Applications", data: Object.values(purposeCounts), backgroundColor: "#0082c8" }]
    }
  });
}

// Download filtered applications
document.getElementById("downloadApplications").addEventListener("click", () => {
  const district = document.getElementById("filterDistrict").value.toLowerCase();
  const status = document.getElementById("filterStatus").value;

  let filtered = applicationData.filter(r => {
    return (!district || (r.District || "").toLowerCase().includes(district)) &&
           (!status || (r.Status || "Pending") === status);
  });

  if (!filtered.length) {
    alert("No matching applications found.");
    return;
  }

  const headers = Object.keys(filtered[0]);
  const csvRows = [headers.join(",")];
  filtered.forEach(r => csvRows.push(headers.map(h => `"${r[h] || ""}"`).join(",")));

  const blob = new Blob([csvRows.join("\n")], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "applications_filtered.csv";
  a.click();
  URL.revokeObjectURL(url);
});

// proximity analysis javascript
let proximityCircles = [];
let conflictMarkers = [];

document.getElementById("toggleProximity").addEventListener("change", e => {
  if (e.target.checked) {
    runProximityAnalysis();
  } else {
    clearProximityAnalysis();
  }
});

// Rerun analysis when buffer distance changes (if toggle is ON)
document.getElementById("bufferDistance").addEventListener("change", () => {
  if (document.getElementById("toggleProximity").checked) {
    runProximityAnalysis();
  }
});

function runProximityAnalysis() {
  clearProximityAnalysis();
  if (!applicationData.length || !boreholeData.length) {
    alert("No application or borehole data loaded.");
    return;
  }

  const buffer = parseInt(document.getElementById("bufferDistance").value);
  let conflicts = 0;

  applicationData.forEach(app => {
    if (!app.Easting || !app.Northing) return;
    let [lonA, latA] = convertToLatLon(parseFloat(app.Easting), parseFloat(app.Northing));
    if (isNaN(latA) || isNaN(lonA)) return;

    // Draw circle for buffer
    let circle = L.circle([latA, lonA], {
      radius: buffer,
      color: "red",
      weight: 2,
      fillOpacity: 0.05
    }).addTo(map);
    proximityCircles.push(circle);

    // Check boreholes inside radius
    boreholeData.forEach(bh => {
      if (!bh.Easting || !bh.Northing) return;
      let [lonB, latB] = convertToLatLon(parseFloat(bh.Easting), parseFloat(bh.Northing));
      if (isNaN(latB) || isNaN(lonB)) return;

      let dist = map.distance([latA, lonA], [latB, lonB]);
      if (dist <= buffer) {
        conflicts++;
        // Highlight borehole
        let marker = L.circleMarker([latB, lonB], {
          radius: 8,
          fillColor: "yellow",
          color: "red",
          weight: 2,
          opacity: 1,
          fillOpacity: 0.9
        }).bindTooltip(`Conflict Borehole<br><b>Name:</b> ${bh.Name || "-"}`);
        marker.addTo(map);
        conflictMarkers.push(marker);
      }
    });
  });

  document.getElementById("proximitySummary").innerText =
    conflicts > 0
      ? `‚ö†Ô∏è ${conflicts} borehole(s) found within ${buffer} m of applications`
      : `‚úÖ No boreholes found within ${buffer} m`;
}

function clearProximityAnalysis() {
  proximityCircles.forEach(c => map.removeLayer(c));
  proximityCircles = [];
  conflictMarkers.forEach(m => map.removeLayer(m));
  conflictMarkers = [];
  document.getElementById("proximitySummary").innerText = "";
}





/* AUTO HIDE BOREHOLE CHART */
(function(){
  var chartCanvas = document.getElementById('boreholeChart');
  if(!chartCanvas) return;
  // hide initially
  var radios = document.querySelectorAll('input[name="boreholeLayer"]');
  var selected = document.querySelector('input[name="boreholeLayer"]:checked');
  if(!selected) chartCanvas.parentElement.style.display = 'none';
  // when toggling checkboxes show/hide chart appropriately via plotBoreholes already calling updateBoreholeChart
})();


// --- Dynamic Layer Order Control ---
function setPaneZIndex(paneName, zIndex) {
  const pane = map.getPane(paneName);
  if (pane) pane.style.zIndex = zIndex;
}

// Boreholes always default on top after reload
map.whenReady(() => {
  setPaneZIndex('boreholesPane', 700);
});

// When a layer is toggled on, bring its pane above others
map.on('layeradd', function(e) {
  try {
    const layer = e.layer;
    if (!layer) return;
    if (layer === boreholeLayerGroup) setPaneZIndex('boreholesPane', 700);
    else if (layer === monitorLayerGroup) setPaneZIndex('monitorPane', 710);
    else if (layer === applicationsLayerGroup) setPaneZIndex('applicationsPane', 710);
    else if (layer === statusLayerGroup) setPaneZIndex('statusPane', 710);
    else if (layer === artesianLayerGroup) setPaneZIndex('artesianPane', 710);
  } catch(err) { console.warn(err); }
});


// ----- Helper: make markers' popups/tooltips show above others and bring layer pane to front -----
function enhanceMarker(marker, paneName) {
  try {
    // ensure marker uses desired pane (already set when created)
    marker.on('mouseover', function(e){
      if (marker.openTooltip) { try{ marker.openTooltip(); } catch(e){} }
      if (marker.openPopup) { try{ marker.openPopup(); } catch(e){} }
      if (marker.bringToFront) try{ marker.bringToFront(); } catch(e){};
      // temporarily bump the pane z-index so popups appear above others
      try { setPaneZIndex(paneName, 820); } catch(err) {}
    });
    marker.on('mouseout', function(e){
      try{ if (marker.closeTooltip) marker.closeTooltip(); } catch(e){}
      try{ if (marker.closePopup) marker.closePopup(); } catch(e){}
      // restore pane z-index after short delay
      setTimeout(function(){ try{ setPaneZIndex(paneName, paneName==='boreholesPane'?700:(paneName==='monitorPane'?660:(paneName==='applicationsPane'?670:690))); }catch(e){} }, 250);
    });
    marker.on('click', function(e){
      try{ marker.openPopup && marker.openPopup(); } catch(e) {}
      try{ marker.bringToFront && marker.bringToFront(); } catch(e) {}
      try { setPaneZIndex(paneName, 840); } catch(err) {}
    });
  } catch(e){ console.warn('enhanceMarker error', e); }
}

// Attach enhancer to markers lists when they are created/updated. For existing arrays we'll try to enhance them after DOM loads.
document.addEventListener('DOMContentLoaded', function(){
  try {
    // enhance boreholes
    if (window.boreholeMarkers) boreholeMarkers.forEach(m => enhanceMarker(m, 'boreholesPane'));
    // enhance status markers
    if (window.statusMarkers) statusMarkers.forEach(m => enhanceMarker(m, 'statusPane'));
    // enhance artesian markers (they are added to artesianLayerGroup on plot)
    if (window.artesianMarkers) artesianMarkers.forEach(m => enhanceMarker(m, 'artesianPane'));
    // enhance monitoring markers inside monitorLayerGroup (iterate layers)
    try {
      if (monitorLayerGroup) monitorLayerGroup.eachLayer(function(l){ enhanceMarker(l, 'monitorPane'); });
    } catch(e){}
    // ensure application markers added to group are enhanced when plotApplications runs (we'll monkey-patch plotApplications)
    const originalPlotApplications = window.plotApplications;
    if (originalPlotApplications) {
      window.plotApplications = function() {
        originalPlotApplications();
        // add created markers in applicationLayerGroup to enhancement
        try { applicationLayerGroup.eachLayer(function(l){ enhanceMarker(l,'applicationsPane'); }); } catch(e){}
      }
    }
    // also wrap plotBoreholes to enhance new borehole markers
    const origPlotBoreholes = window.plotBoreholes;
    if (origPlotBoreholes) {
      window.plotBoreholes = function(){
        origPlotBoreholes();
        try { boreholeLayerGroup.eachLayer(function(l){ enhanceMarker(l,'boreholesPane'); }); } catch(e) {}
      }
    }
  } catch(e){ console.warn('Marker enhancement init failed', e); }
});
// ----- end helper -----


</script>
<script>
// Safety init: attach LULC toggle + legend behavior after DOM loads, and guard against errors.
document.addEventListener("DOMContentLoaded", function () {
  try {
    const toggleLULCEl = document.getElementById("toggleLULC");
    const lulcLegendEl = document.getElementById("lulcLegend");
    if (toggleLULCEl) {
      // Set initial visibility based on checkbox state
      if (lulcLegendEl) lulcLegendEl.style.display = toggleLULCEl.checked ? "block" : "none";
      // LULC Opacity slider linkage
      const lulcOpacitySlider = document.getElementById('lulcOpacity');
      if (lulcOpacitySlider && typeof lulcLayer !== 'undefined') {
        try { lulcLayer.setOpacity(parseFloat(lulcOpacitySlider.value)); } catch(e) {}
        lulcOpacitySlider.addEventListener('input', function(ev){
          const v = parseFloat(ev.target.value);
          try { if (typeof lulcLayer !== 'undefined') lulcLayer.setOpacity(v); } catch(err){}
        });
      }

      toggleLULCEl.addEventListener("change", (e) => {
        try {
          if (e.target.checked) {
            if (typeof map !== "undefined" && typeof lulcLayer !== "undefined") {
              try { map.addLayer(lulcLayer); } catch(err){ console.warn("Could not add LULC layer:", err); }
            }
            if (lulcLegendEl) lulcLegendEl.style.display = "block";
          } else {
            if (typeof map !== "undefined" && typeof lulcLayer !== "undefined") {
              try { map.removeLayer(lulcLayer); } catch(err){ console.warn("Could not remove LULC layer:", err); }
            }
            if (lulcLegendEl) lulcLegendEl.style.display = "none";
          }
        } catch(evtErr){ console.error("Error in toggle handler:", evtErr); }
      });
    }
  } catch(e) { console.error("Init script error:", e); }
});
</script>
<script>
/* ==== GW-QUALITY SYSTEM (Full Version with Custom Ranges) ==== */

// 1Ô∏è‚É£ Define your exact quality ranges for each parameter
const qualityRanges = {
    "Turbidity":        [2, 5, 50],
    "Temp":             [20, 25, 30],
    "Conductivity":     [750, 1500, 3000],
    "pH":               [7.0, 7.5, 8.0],
    "Alkalinity":       [200, 300, 400],
    "Hardness":         [100, 200, 400],
    "Calcium":          [10, 20, 50],
    "Magnesium":        [5, 10, 50],
    "Sodium":           [100, 200, 400],
    "Potassium":        [1, 2, 4],
    "Carbonate":        [2, 4, 8],
    "Bicarbonate":      [50,150,300],
    "Sulphate":         [50,150,300],
    "Nitrate":          [25, 50, 100],
    "Ammonium":         [0.75, 1.5, 3.0],
    "Iron":             [0.15, 0.30, 0.60],
    "Manganese":        [0.2, 0.4, 0.8],
    "Flouride":         [0.75, 1.5, 3.0],
    "Chlorine":         [125, 250, 500]
};


// Colors for the 4 categories
const gwColors = ["#2ca02c", "#ffcc00", "#ff9900", "#d62728"];  
              //   Low        Moderate     High      Very High

let gwQualityData = [];
let gwQualityLayer = L.layerGroup().addTo(map);


// 2Ô∏è‚É£ Load your GW-Quality CSV from GitHub
Papa.parse("https://nationalwaterresourcesauthorit-commits.github.io/groundwater-section/boreholedata.csv", {
    download: true,
    header: true,
    dynamicTyping: true,
    complete: function(res) {
        gwQualityData = res.data;
    }
});


// 3Ô∏è‚É£ Function: determine category index (0‚Äì3) based on user ranges
function getQualityCategory(param, value) {
    if (value === null || value === "" || isNaN(value)) return -1;

    const v = parseFloat(value);
    const ranges = qualityRanges[param];
    if (!ranges) return -1;

    if (v < ranges[0]) return 0;
    if (v < ranges[1]) return 1;
    if (v < ranges[2]) return 2;
    return 3;
}


// 4Ô∏è‚É£ Plot markers for the selected parameter
function plotGWQuality(param) {
    gwQualityLayer.clearLayers();
    if (!param) return;

    gwQualityData.forEach(row => {
        let E = parseFloat(row.Easting);
        let N = parseFloat(row.Northing);
        if (!E || !N) return;

        let [lon, lat] = convertToLatLon(E, N);

        const val = row[param];
        const cat = getQualityCategory(param, val);

        const color = (cat === -1) ? "#000000" : gwColors[cat];

        L.circleMarker([lat, lon], {
            radius: 6,
            color: "#333",
            fillColor: color,
            fillOpacity: 0.85,
            weight: 1,
            pane: "boreholesPane"
        }).bindTooltip(`
            <b>${param}:</b> ${val ?? "-"}<br>
            <b>Name:</b> ${row.Name || "-"}
        `).addTo(gwQualityLayer);
    });

    updateGWQualityLegend(param);
}


// 5Ô∏è‚É£ Update legend with your exact ranges
function updateGWQualityLegend(param) {
    const legend = document.getElementById("gwQualityLegend");
    let r = qualityRanges[param];

    legend.innerHTML = `
        <b>${param} Ranges</b><br>
        <i style="background:${gwColors[0]}"></i> < ${r[0]}<br>
        <i style="background:${gwColors[1]}"></i> ${r[0]} ‚Äì ${r[1]}<br>
        <i style="background:${gwColors[2]}"></i> ${r[1]} ‚Äì ${r[2]}<br>
        <i style="background:${gwColors[3]}"></i> > ${r[2]}<br>
        <i style="background:#000000"></i> Unknown
    `;
}


// 6Ô∏è‚É£ Dropdown listener
document.getElementById("gwQualitySelect").addEventListener("change", function () {
    plotGWQuality(this.value);
});

</script>

</div></body>
</html>